#!/usr/bin/env bash
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
. $DIR/sc-_common
HISTFILE="$MDIR/history"
HISTSIZE=1000
INJECT=
MDREAD='sd -c <(echo -e "[style]\nMargin = 4")'
LLM_MODEL=
[[ -r "$MDIR/DUI" ]] || echo OFF > "$MDIR/DUI"
DUI=$(< "$MDIR/DUI" )
DUIPROMPT='(Note: You are now in Do-Ur-Inspection mode: the contents of "command" code blocks with a syntax type AGENT will run. For example, ```AGENT\nls``` will run ls. Only run what is necessary. Remember, if you mention it N times, N things will run, so use it carefully. If you want the user to run something, do not use the special syntax. That is only for you. Your current path is '$PWD')'
CAPTURE="ON"
USECLIP=
LAUNCH="$0"
RETRY=
TOOLS=

[[ "$_uname" == "Darwin" ]] && msize="-f %z" || msize="-c %s"
     
_warn() {
    echo -e "**âš ï¸** *$@*" | $MDREAD
}

show_params() {
    eval "$(tmux list-panes -a -F "#{pane_id}=#{pane_index}" | tr '%\n' '_;' )"
    {
        echo -n "  * **Shared:** [ "
        for _ix in "${pane_list[@]}"; do
            local v="${_ix/\%/_}"
            echo -n " ${!v}"
        done
        echo " ]"
    }
    if [[ "$#" -gt 0 && "$1" == "panes" ]]; then
        return
    fi
    echo -n "  * **Model**:  ${LLM_MODEL:-*(None Set)*}"
    [[ "$TOOLS" == "ON" ]] && echo " ðŸ› " || echo ""

    echo -n "  * **Server**: ${SERVER_URL:-*(Needs to be configured)*}"
    [[ -n "$SERVER_AUTH" ]] && echo " ðŸ”’" || echo " ðŸ”“"

    local size="$(stat $msize "$convo_id")"
    echo "  * **Convo**:  ${convo_id} ($size B)"
    echo "  * **Config**: ${SETTINGS}"
}

help() {
  if [[ "$#" -gt 0 ]]; then 
    {
        echo "### Parameters  (*[sidechat $VERSION](https://github.com/day50-dev/sidechat)*)"
        echo "  * **System Prompt**:"
        echo "$SYSTEM" | sed 's/^/> /g'
        show_params
        echo -e "\n### Commands"

    } | $MDREAD
  fi
  cat <<END
  /choose   - Choose shared panes
  /clip     - Select text into the clipboard as context
  /mindwipe - Forget this crazy world and start over
  /sshot    - Raster screenshot
  /dui      - Toggle agentic (current: $DUI)
  /capture  - Toggle capture (current: $CAPTURE)
  cmd | sc-add [-c cid] [prompt] - Add the output of cmd to the context
END
  if [[ "$#" -ne 0 ]]; then 
cat <<END
  /model | /server | /key - change the {model, server, key}
  /prev     - Load a previous conversation
  /flash    - Flash the shared panes
  /update   - Self-update
  /retry    - Try the last request again
  /tools    - Toggle Tools (current: $TOOLS)
  /edit     - Edit the internal state
END
  fi
}

nlchomp() {
  [[ "$_uname" == "Darwin" ]] && awk '{printf "%s, ", $0} END{print ""}' || sed -z 's/\n/, /g' 
}

onload() {
    [[ -r $HOME/.local/bin/sd ]] && MDREAD=$HOME/.local/bin/sd
    [[ -f "$HISTFILE" ]] || touch "$HISTFILE"

    SYSTEM="You're an interactive buddy in tmux talking to a competent engineer whose instincts are better than yours. If they disagree with you, trust them and don't argue. Your job is mostly either small things like syntax or arcane knowledge. It's generally not architecture or design. Assume they've already tried what a competent engineer would do.  You will get capture-pane -p followed by questions when the pane output changes.  They are using $(uname -ar). Notices to you come in the form (Note: <message>). They can do the following: $(help | nlchomp)"

    if [[ -s "$CONFIG/memories.json" ]]; then
        SYSTEM="$SYSTEM. User memories: $(jq -r ".[]" "$CONFIG/memories.json" | sed -E 's/your?\s/user /ig' | nlchomp )"
    fi
    history -r "$HISTFILE"
    trap 'history -w "$HISTFILE"' EXIT

    if [[ "$_uname" == "Linux" ]]; then
      llm_config=".config"
    else
      llm_config="Library/Application Support"
    fi

    [[ -n "$TMUX" ]] && my_id=$(tmux display-message -p '#{pane_id}') || my_id=

    pane_id=${1-}
    pane_list=( $pane_id )
    convo_id=
    forcecapture=
    debug=
    if [[ -r "$MDIR/${pane_id}.convo" ]]; then 
        convo_id=$(cat "$MDIR/${pane_id}.convo")
    fi
    if [[ -z "$convo_id" ]]; then 
        newconvo 
    else
        flash 1
    fi

    touch "$MDIR/${pane_id}.convo"
    touch "$MDIR/${pane_id}.old"

    load_pref
    set_prompt

    ata=""
    if [[ -n "$convo_id" ]]; then
        last 5
    else
        echo "Conversation Start: Type /help for options"
    fi
}

update() {
    tmux split-window -v "curl -s https://day50.dev/sidechat | sh; tmux wait-for -S upgrade"
    tmux wait-for upgrade
    echo -e "## And now the magical in-place upgrade\n" | $MDREAD
    exec "$LAUNCH" $pane_id
}

flash() {
    [[ -z "$1" ]] && show_params panes | $MDREAD
    if [[ -n "$TMUX" ]]; then
        for ix_pane in "${pane_list[@]}"; do
            tmux select-pane -t $ix_pane -P 'bg=colour95'; sleep 0.03
            tmux select-pane -t $ix_pane -P 'bg=color129'; sleep 0.03
            tmux select-pane -t $ix_pane -P 'bg=default' 
        done
        tmux select-pane -t $my_id
    fi
    set_prompt
}

retry() {
    RETRY=1
}

load_pref() {
    [[ -e "$SETTINGS" ]] && source "$SETTINGS"
}

save_pref() {
    local vname="$1"
    local stanza="$vname='$2'"
    local tmp="${SETTINGS}.tmp"
    [[ -d "$CONFIG" ]] || mkdir "$CONFIG"
    [[ -e "$SETTINGS" ]] || touch "$SETTINGS"
    { grep -vE "^${vname}=" "$SETTINGS" ; echo "$stanza"; } > "$tmp"
    mv "$tmp" "$SETTINGS"
    eval "$stanza"
}

key() {
    local input
    {
        echo -e "The auth token:\n"
        echo " * Does not echo"
        echo -e " * Is stored in plaintext\n"
    } | $MDREAD
    read -sE -p "  Enter token: " input
    if [[ -n "$input" ]]; then
        SERVER_AUTH="$input"
        save_pref SERVER_AUTH "$SERVER_AUTH"
    else
        _warn "Cancelled. (To clear a key, replace it with something bogus, like a space)"
    fi
}
server() {
    local SERVER_URL_
    local input
    {
        echo -e "The server URL:\n"
        echo " * Should include the schema, such as \`http://\` or \`https://\`"
        echo " * Be OpenAI compatible (e.g., litellm/llama.cpp/ollama/openrouter/etc)"
        echo " * Can be some special values: "
        echo "   * \`or\`     - openrouter"
        echo "   * \`ollama\`  - ollama    (local)"
        echo -e "   * \`llama\`  - llama.cpp (local)\n"
    } | $MDREAD
    builtin read -p "  Enter URL: " input
    if [[ -n "$input" ]]; then
        case $input in 
            or) getkey=1; SERVER_URL_=https://openrouter.ai/api ;;
            ollama) SERVER_URL_=http://localhost:11434 ;;
            llama) SERVER_URL_=http://localhost:8080 ;;
        esac
        SERVER_URL="$input"
        if [[ -n "$SERVER_URL_" ]]; then
            echo -e " Using \`$SERVER_URL_\`" |$MDREAD
            SERVER_URL="$SERVER_URL_"
        fi

        if [[ ! "${SERVER_URL@L}" =~ "http" ]]; then
            _warn "This is a very unusual url, testing...\n"
            if ! llcat -u $SERVER_URL -m > /dev/null; then
                echo -e "\n  Yep! Thought so, let's try this again!\n"
                server
            fi
        fi
            
        save_pref SERVER_URL "$SERVER_URL"
        if [[ -n "$getkey" && -z "$SERVER_AUTH" ]]; then
            echo
            key
        fi
    else
        _warn "Cancelled"
    fi
}

check() {
    if [[ "$1" =~ (server|both) && -z "$SERVER_URL" ]]; then 
        _warn "You need to set a server before continuing"
        echo
        server
    fi
    if [[ "$1" =~ (model|both) && -z "$LLM_MODEL" ]]; then 
        model
    fi
}

model() {
    check server
    chosen=$(ll -m | sort | fzf-tmux )
    if [[ -n "$chosen" ]]; then
      echo "  Setting model to \`$chosen\`" | $MDREAD
      save_pref LLM_MODEL "$chosen"
    fi
}

set_prompt() {
    local camera=""
    local dui=""
    local clipboard=""
    [[ -n "$TMUX" && "$CAPTURE" == "ON" ]] && camera="ðŸ“·"
    [[ "$DUI" == "ON" ]] && dui="ðŸš—"
    [[ -n "$USECLIP" ]] && clipboard='ðŸ“‹'
    prompt="${camera}${dui}${clipboard} > "
}

edit() {
    local fname=$(
        {
         sd --help | grep '^  config' | rev | cut -d ' ' -f 1 | rev;
         echo $convo_id;
         echo $SETTINGS;
         echo $CONFIG/memories.json;
        } | fzf --style full --preview "batcat {}"
    )
    [[ -z "$fname" ]] && _warn Cancelled || $EDITOR "$fname"
}

choose() {
    local depth=${1:-0}
    [[ "$depth" == 0 ]] && echo "Select panes or any other key to end selection" | $MDREAD
    [[ -z "$TMUX" ]] && return
    tmux display-panes -d 0 "run-shell 'echo %% > $MDIR/pane-id'"
    if [[ $? == "1" ]] ; then
        echo "Exiting due to possible infinite loop."
        exit 1
    fi
    if [[ -e "$MDIR/pane-id" ]]; then 
        pane_id=$(cat "$MDIR/pane-id")
        [[ "$depth" == 0 ]] && pane_list=( )
        pane_list+=( $pane_id )
        (( depth ++ ))
        flash
        rm "$MDIR/pane-id"
        tmux select-pane -t $my_id
        touch "$MDIR/${pane_id}."{convo,old}
        INJECT=" (Note: User changed tmux panes)"

        # If you're choosing something you probably also want to capture
        # I had forgotten the flow and was running choose a few times 
        # wondering why it wasn't capturing
        choose "$depth"
    else
        [[ "$depth" == "0" ]] && echo "Cancelled" 
        return 1
    fi
    if [[ "$CAPTURE" == "OFF" ]]; then
        capture
    fi
    read -t 0.05 -n 1
    return 0
}

getlast(){
    local wid=$(( $(tput cols) / 2 ))
    find $MDIR -name c-\* -size +0c | \
        rev | cut -d '/' -f 1 | rev | \
        fzf --style full --preview "sd -w $wid <(jq -r '.[] | select(.role != \"system\") | \"\n**\(.role)**: \(.content)\"' \"$MDIR\"/{} | tail -40)"
}

prev() {
    choice=$(getlast)
    if [[ -z "$choice" ]]; then
        _warn "Cancelled"
    else
        convo_id="$MDIR/$choice"
        echo "$convo_id" > "$MDIR/${pane_id}.convo"
        last
    fi
}

tools() {
    [[ "$TOOLS" == "ON" ]] && TOOLS="OFF" || TOOLS="ON"
    _warn "Tools are ${TOOLS@L}" 
    save_pref TOOLS "$TOOLS"
}

last() {
    amount=${1:-40}
    { 
        show_params; 
        echo -e "\n------\n"; 
        jq -r '.[] | "\n**\(.role)**: \(.content)"' $convo_id | tail -$amount; 
    } | $MDREAD
}

ll() {
    local tool=
    [[ "$TOOLS" == "ON" ]] && tool="-tf $DIR/sc-tf.json -tp $DIR/sc-tp.py"

    llcat -c "$convo_id" $tool \
        -u "$SERVER_URL" -s "$SYSTEM" \
        -sk "$SERVER_AUTH" "$@" 2> >(jq '.' >&2) 
}

llc() {
    ll -m "$LLM_MODEL" "$@"
}

newconvo() {
    day=$(date +%m%d-%H%M)
    convo_id=$(mktemp "$MDIR/c-$day-XXXX")
    echo $convo_id > "$MDIR/${pane_id}.convo"
    _warn "New convo is $convo_id"
}

mindwipe() {
    newconvo
    forcecapture=1
}

process_cmd() {
    infile="$1"
    n=$2
    local base="${infile}.${n}"
    {
        local llm_in="${base}-IN"
        local llm_parse="${base}-OUT"
        #echo $llm_in $llm_parse
        err=0

        for cmdfile in $(cat "$base" | "$DIR/sc-_parse.py" -r '```AGENT\n(.*)```' -b "$llm_parse"); do
            #echo "## $cmdfile"
            if [[ $DUI == "ON" ]]; then
                cmd=$( < "$cmdfile" )
                cat "$cmdfile" | grep -v '^$' | tee -a "$llm_in" | sed 's/^/### /g' 
                echo '```bash'
                { 
                    echo "set -eEuo pipefail"; 
                    cat "$cmdfile"; } > "${cmdfile}.safe"
                {
                    bash "${cmdfile}.safe" | tee -a $llm_in | head -30
                    [[ $? -ne 0 ]] && err=$?
                }
                echo '```'
            else
                echo "~~ $match ~~ "
            fi
        done

        if [[ $err == 0 && "$DUI" == "ON" && -s "$llm_in" ]]; then
            (( n++ ))
            cat "$llm_in" | ll "You ran Do-Ur-Inspection commands"   
        fi
    } | $MDREAD
}

capture() {
    if [[ "$CAPTURE" == "ON" ]]; then
        echo "Capturing off. Shades are drawn!"
        save_pref "CAPTURE" "OFF"
        INJECT="$INJECT (Note: User turned capture off)"
    else
        if [[ -n "$TMUX" ]]; then
          while ! tmux list-panes -t "$pane_id" &>/dev/null; do
              echo "Woops, the pane disappeared. Choose another!"
              choose
          done

          flash
          echo "Capturing on. I see you!"
          INJECT="$INJECT (Note: User turned capture on)"
        else
          echo "No TMUX... No capture"
        fi
        save_pref "CAPTURE" "ON"
    fi
}

clip_nvim() {
    nvim --headless --cmd "echo getreg('+')" --cmd "qa" 2>&1
}

clip() {
    USECLIP=
    local xclip=$(command -v xclip)
    local nvim=$(command -v nvim)
    local pbpaste=$(command -v pbpaste)
    local emacs=$(command -v emacsclient) 

    if [[ -n "$xclip" ]]; then
        for i in p c s; do 
            xclip -o -${i} > "$MDIR/clip.$i"
        done
    fi

    tmux show-buffer > "$MDIR/clip.tmux" 2> /dev/null

    if [[ -n "$pbpaste" ]]; then
       pbpaste > "$MDIR/clip.pbpaste"
    fi

    if [[ -n "$nvim" ]]; then
       clip_nvim > "$MDIR/clip.nvim"
    fi

    if [[ -n "$emacs" ]]; then
        emacsclient --eval '(current-kill 0)' > "$MDIR/clip.emacs" 2>/dev/null
    fi

    {
        echo "Select the text you want to send and I'll find out what clipboard it is, hopefully..."
        echo -n 'Supported: `tmux` '
        [[ -n "$nvim" ]]    && echo -n '`nvim` '    || echo -n '~~`nvim`~~ '
        [[ -n "$pbpaste" ]] && echo -n '`pbpaste` ' || echo -n '~~`pbpaste`~~ '
        [[ -n "$xclip" ]]   && echo -n '`xsel` '     || echo -n '~~`xsel`~~ '
        [[ -n "$emacs" ]]   && echo -n '`emacs` '    || echo -n '~~`emacs`~~ '
        echo
        echo
    } | $MDREAD
    
    while [[ 0 ]]; do
        if [[ -n "$xclip" ]]; then
            for i in p c s; do 
                if ! diff <(xclip -o -${i}) "$MDIR/clip.$i" > /dev/null; then
                    USECLIP="xclip -o -${i}"
                    break 2
                fi
            done
        fi

        if [[ -n "$emacs" ]]; then
            if ! diff <(emacsclient --eval '(current-kill 0)' 2>/dev/null) "$MDIR/clip.emacs" > /dev/null; then
                USECLIP="emacsclient --eval '(current-kill 0)' 2>/dev/null"
                break
            fi
        fi

        if [[ -n "$pbpaste" ]]; then
            if ! diff <(pbpaste) "$MDIR/clip.pbpaste" > /dev/null; then
                USECLIP=pbpaste
                break
            fi
        fi

        if [[ -n "$nvim" ]]; then
            if ! diff <(clip_nvim) "$MDIR/clip.nvim" > /dev/null; then
                USECLIP=clip_nvim
                break
            fi
        fi
        if ! diff <(tmux show-buffer 2>/dev/null) "$MDIR/clip.tmux" > /dev/null; then
            USECLIP="tmux show-buffer"
            break
        fi
        sleep 0.3
    done

    if [[ -n "$USECLIP" ]]; then
        {
            echo -e "\nFound!\n### Next prompt will use \`$USECLIP\`"
        } | $MDREAD
    else
        echo "Aborted"
    fi
}

dui() {
    if [[ "$DUI" == "ON" ]]; then
        DUI=OFF
        echo "Sobering up.";
        llc "(Note: Do-Ur-Inspection is now off. Do not talk about it. It no longer exists. Piping into sc-add is still available)"
    else
        DUI=ON
        echo "Fuck it, let's roll!"
        llc "$DUIPROMPT"
    fi
    echo $DUI > "$MDIR/DUI"
} 


emit_capture() {
    local ix=$1
    echo " has_changed=True>"
    [[ -n "$TMUX" && -s "$MDIR/${ix_pane}.new" ]] && _pid=$(tmux display -pt "$ix" '#{pane_pid}')

    if [[ "$_uname" == "Linux" && -n "$TMUX" ]]; then
        echo "<ps hierarchy>$(ps -o comm= --ppid $_pid -p $_pid | tr '\n' ' ')</ps hierarchy>"
    fi
    echo "<capture>"
    cat "$MDIR/${ix}.new"
    echo "</capture>"
}

onload $@

while [ 0 ]; do 
    echo
    input=""
    pline="$prompt"
    while IFS= read -rep "$pline" line || exit; do
        if [[ "$line" == *\\ ]]; then
            input+="${line%\\}"
            input+=$'\n'
        else
            input+="$line"
            break
        fi
        pline="   |  "
    done
    [[ -z "$input" ]] && continue
    echo 

    _uuid=$(date +%s.%N)

    history -s "$input"  # Save to history
 
    if [[ $input =~ ^/ ]]; then
        if [[ $input == '/debug' ]]; then
            if [[ -n "$debug" ]]; then
                _warn "Debug Off"
                debug=; set +x; 
            else
                _warn "Debug On"
                debug=1; set -x; 
            fi
        elif [[ $input =~ ^/sshot ]]; then
            sshot=$(mktemp --suffix=.png -p "$MDIR")
            import $sshot
            ata="-a $sshot"
            echo "Next prompt will use your screenshot"
        elif [[ $input =~ (choose|clip|capture|dui|edit|flash|key|mindwipe|model|prev|retry|server|tools|update) ]]; then
            ${input:1}
        else
            help 1
        fi
        set_prompt
        # if we are retrying the last we want the same everything
        [[ -z "$RETRY" ]] && continue
    else
        text="$input"
    fi

    if [[ -z "$USECLIP" && $CAPTURE == "ON" && -n "$TMUX" ]]; then
        for ix_pane in "${pane_list[@]}"; do
          tmux capture-pane -t "${ix_pane}" -p > "$MDIR/${ix_pane}.new"
          [[ -s "$MDIR/${ix_pane}.new" ]] || echo "**WARNING: Can't capture ${ix_pane}, Use /choose to update**" | $MDREAD
        done
    fi
    
    # If we get here now we know to be picky about if there's a model and a server
    check both
    n=0
    in="$MDIR/${convo_id}_${_uuid}"
    {
       if [[ -n "$USECLIP" ]]; then
           echo "<clipboard>"
           $USECLIP
           echo "</clipboard>"
       elif [[ "$CAPTURE" == "ON" ]]; then
         for ix_pane in "${pane_list[@]}"; do
            echo -n "<pane id=$ix_pane"
            if [[ -n "$RETRY" ]]; then
                cp "$MDIR/${ix_pane}.old" "$MDIR/${ix_pane}.new"
                emit_capture "$ix_pane"
            else
                if [[ -e "$MDIR/${ix_pane}.old" && -z "$forcecapture" ]]; then
                    /usr/bin/diff "$MDIR/${ix_pane}.new" "$MDIR/${ix_pane}.old" > /dev/null && echo -n " has_changed=False>" || emit_capture "$ix_pane"
                else
                    emit_capture "$ix_pane"
                fi
                cp "$MDIR/${ix_pane}.new" "$MDIR/${ix_pane}.old"
            fi
            echo "</pane>"
         done
      fi
    } | llc $ata "${text}${INJECT}" 2> >(jq . >&2) | spinner $MDREAD 

    # Needs to be run here and not in any subshell
    RETRY=
    INJECT=
    ata=""
    [[ -n "$USECLIP" ]]      && USECLIP=
    [[ -n "$forcecapture" ]] && forcecapture=
    set_prompt

    if [[ "$DUI" == "ON" ]]; then
        while true; do
            process_cmd "$in" $n
            (( n++ ))
            [[ -s "${in}.${n}" ]] || break
        done
    fi
done
